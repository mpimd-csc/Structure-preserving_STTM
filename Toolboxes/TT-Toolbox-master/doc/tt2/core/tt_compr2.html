<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of tt_compr2</title>
  <meta name="keywords" content="tt_compr2">
  <meta name="description" content="Tensor rounding in TT1.0 format">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">tt2</a> &gt; <a href="index.html">core</a> &gt; tt_compr2.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for tt2/core&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>tt_compr2
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Tensor rounding in TT1.0 format</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [tt] = tt_compr2(tt,eps, max_r) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">Tensor rounding in TT1.0 format
   [TT]=TT_COMPR2(TT,EPS) Reapproximates the given TT-tensor with 
   prescribed accuracy EPS. Please avoid its usage: it will be removed in
   future releases. Use round() from the object-oriented version


 TT-Toolbox 2.2, 2009-2012

This is TT Toolbox, written by Ivan Oseledets et al.
Institute of Numerical Mathematics, Moscow, Russia
webpage: http://spring.inm.ras.ru/osel

For all questions, bugs and suggestions please mail
ivan.oseledets@gmail.com
---------------------------</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="../../tt2/@qtt_tucker/diag.html" class="code" title="function [qt]=diag(qt)">diag</a>	Diagonal of a matrix or diagonal matrix from a vector in QTT-Tucker</li><li><a href="../../tt2/@qtt_tucker/norm.html" class="code" title="function [nrm] = norm(tt)">norm</a>	Frobenius norm of the QTT-Tucker</li><li><a href="../../tt2/@tt_matrix/conj.html" class="code" title="function [b]=conj(a)">conj</a>	Complex conjugate of a TT-matrix</li><li><a href="../../tt2/@tt_matrix/core.html" class="code" title="function [tt] = core(tt1,varargin)">core</a>	Converts TT-matrix to TT1 cell-array format</li><li><a href="../../tt2/@tt_matrix/diag.html" class="code" title="function [tt]=diag(tm)">diag</a>	Extract the diagonal of the TT-matrix</li><li><a href="../../tt2/@tt_matrix/norm.html" class="code" title="function [nrm] = norm(t,varargin)">norm</a>	Matrix norm of the TT-matrix</li><li><a href="../../tt2/@tt_matrix/size.html" class="code" title="function [sz] = size(tt)">size</a>	Mode sizes of the TT-matrix</li><li><a href="../../tt2/@tt_tensor/conj.html" class="code" title="function [tt1]=conj(tt)">conj</a>	Compute a complex conjugate of TT-tensor</li><li><a href="../../tt2/@tt_tensor/core.html" class="code" title="function [tt] = core(tt1,varargin)">core</a>	Converts TT-tensor TT1 to old-cell array format.</li><li><a href="../../tt2/@tt_tensor/diag.html" class="code" title="function [tm]=diag(tt)">diag</a>	Constructs diagonal TT-matrix from TT-tensor</li><li><a href="../../tt2/@tt_tensor/norm.html" class="code" title="function [nrm] = norm(tt)">norm</a>	Frobenius norm of the TT-tensor</li><li><a href="../../tt2/@tt_tensor/qr.html" class="code" title="function [tt,rm]=qr(tt,op)">qr</a>	Left and right orthogonalization of the TT-format</li><li><a href="../../tt2/@tt_tensor/reshape.html" class="code" title="function [tt2]=reshape(tt1,sz,eps, rl, rr)">reshape</a>	Reshape of the TT-tensor</li><li><a href="../../tt2/@tt_tensor/size.html" class="code" title="function [sz] = size(tt,dim)">size</a>	Mode sizes of the TT-tensor</li><li><a href="ten_conv.html" class="code" title="function [new_core] = ten_conv(core, k, mat)">ten_conv</a>	Tensor-by-matrix multiplication of three-dimensional tensor</li><li><a href="tt_dot2.html" class="code" title="function [res,sgn] = tt_dot2(tt1,tt2)">tt_dot2</a>	Logarithm of the scalar product of two tensor (to avoid overflow)</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="tt_axpy.html" class="code" title="function [res]=tt_axpy(a, x, p, y, eps, max_rank)">tt_axpy</a>	Returns A*X+P*Y in the TT-format.</li><li><a href="tt_axpy2.html" class="code" title="function [res] = tt_axpy2(log_a, sign_a, x, log_p, sign_p, y, eps, max_rank)">tt_axpy2</a>	Returns A*X+P*Y in the TT-format (stabilized version)</li><li><a href="tt_mat_compr.html" class="code" title="function [res]=tt_mat_compr(mat,eps, max_rank)">tt_mat_compr</a>	Tensor rounding for the TT-matrix in TT1.0 format</li><li><a href="../../tt2/exp/canm_to_qtt.html" class="code" title="function [tt]=canm_to_qtt(can,rmax,eps)">canm_to_qtt</a>	Converts a canonical representation to QTT-format</li><li><a href="../../tt2/solve/dmrg_rake_solve2.html" class="code" title="function [x]=dmrg_rake_solve2(A, y, tol, varargin)">dmrg_rake_solve2</a>	DMRG-type method for the solution of linear systems in QTT-Tucker format</li><li><a href="../../tt2/solve/dmrg_solve2.html" class="code" title="function [x, sweeps]=dmrg_solve2(A, y, eps,varargin)">dmrg_solve2</a>	Solution of linear systems in TT-format via DMRG iteration</li><li><a href="../../tt2/solve/tt_iterapp.html" class="code" title="function y = tt_iterapp(op,afun,atype,afcnstr,x,eps,max_rank,max_swp,varargin)">tt_iterapp</a>	Apply TT matrix operator to TT vector and error gracefully.</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [tt] = tt_compr2(tt,eps, max_r)</a>
0002 <span class="comment">%Tensor rounding in TT1.0 format</span>
0003 <span class="comment">%   [TT]=TT_COMPR2(TT,EPS) Reapproximates the given TT-tensor with</span>
0004 <span class="comment">%   prescribed accuracy EPS. Please avoid its usage: it will be removed in</span>
0005 <span class="comment">%   future releases. Use round() from the object-oriented version</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%</span>
0008 <span class="comment">% TT-Toolbox 2.2, 2009-2012</span>
0009 <span class="comment">%</span>
0010 <span class="comment">%This is TT Toolbox, written by Ivan Oseledets et al.</span>
0011 <span class="comment">%Institute of Numerical Mathematics, Moscow, Russia</span>
0012 <span class="comment">%webpage: http://spring.inm.ras.ru/osel</span>
0013 <span class="comment">%</span>
0014 <span class="comment">%For all questions, bugs and suggestions please mail</span>
0015 <span class="comment">%ivan.oseledets@gmail.com</span>
0016 <span class="comment">%---------------------------</span>
0017 
0018 d = <a href="../../tt2/@tt_matrix/size.html" class="code" title="function [sz] = size(tt)">size</a>(tt,1);
0019 <span class="comment">%First, estimate the logarithm of the squared norm, and then --- the norm</span>
0020 <span class="comment">%of each core :-)</span>
0021 nrm_full=<a href="tt_dot2.html" class="code" title="function [res,sgn] = tt_dot2(tt1,tt2)">tt_dot2</a>(tt,tt);
0022 nrm1=nrm_full/(2*d); nrm1=exp(nrm1);
0023 
0024 exists_max_r=1;
0025 <span class="keyword">if</span> ((nargin&lt;3)||(isempty(max_r)))
0026     exists_max_r=0;
0027 <span class="keyword">end</span>;
0028 
0029 <span class="keyword">if</span> ( nrm_full &lt; log(1e-200) ) <span class="comment">%Something really small</span>
0030   n=<a href="../../tt2/@tt_matrix/size.html" class="code" title="function [sz] = size(tt)">size</a>(tt{1},1);
0031   tt{1}=zeros(n,1);
0032   n=<a href="../../tt2/@tt_matrix/size.html" class="code" title="function [sz] = size(tt)">size</a>(tt{d},1);
0033   tt{d}=ones(n,1);
0034   <span class="keyword">for</span> i=2:d-1
0035   n=<a href="../../tt2/@tt_matrix/size.html" class="code" title="function [sz] = size(tt)">size</a>(tt{i},1);
0036   tt{i}=ones(n,1,1);
0037   <span class="keyword">end</span>
0038   <span class="keyword">return</span>
0039 <span class="keyword">end</span>
0040 <span class="comment">%nrmf=zeros(d,1); %Place to store the norms of QR-factors</span>
0041 <span class="comment">%first, we orthogonalize the tensor from right to left until the first mode</span>
0042 mat=tt{d};
0043 [q,rv]=<a href="../../tt2/@tt_tensor/qr.html" class="code" title="function [tt,rm]=qr(tt,op)">qr</a>(mat,0); rv=rv./nrm1; q=q.*nrm1;
0044 tt{d}=q;
0045 <span class="keyword">for</span> i=(d-1):-1:2
0046     tt{i} = <a href="ten_conv.html" class="code" title="function [new_core] = ten_conv(core, k, mat)">ten_conv</a>(tt{i},3,<a href="../../tt2/@tt_matrix/conj.html" class="code" title="function [b]=conj(a)">conj</a>(rv'));
0047     ncur=<a href="../../tt2/@tt_matrix/size.html" class="code" title="function [sz] = size(tt)">size</a>(tt{i},1);
0048     r2=<a href="../../tt2/@tt_matrix/size.html" class="code" title="function [sz] = size(tt)">size</a>(tt{i},2);
0049     r3=<a href="../../tt2/@tt_matrix/size.html" class="code" title="function [sz] = size(tt)">size</a>(tt{i},3);
0050     <a href="../../tt2/@tt_matrix/core.html" class="code" title="function [tt] = core(tt1,varargin)">core</a>=permute(tt{i},[1,3,2]);
0051     <a href="../../tt2/@tt_matrix/core.html" class="code" title="function [tt] = core(tt1,varargin)">core</a>=<a href="../../tt2/@tt_tensor/reshape.html" class="code" title="function [tt2]=reshape(tt1,sz,eps, rl, rr)">reshape</a>(<a href="../../tt2/@tt_matrix/core.html" class="code" title="function [tt] = core(tt1,varargin)">core</a>,[ncur*r3,r2]);
0052     [tt{i},rv]=<a href="../../tt2/@tt_tensor/qr.html" class="code" title="function [tt,rm]=qr(tt,op)">qr</a>(<a href="../../tt2/@tt_matrix/core.html" class="code" title="function [tt] = core(tt1,varargin)">core</a>,0); rv=rv./nrm1;
0053     rnew=min(r2,ncur*r3);
0054     tt{i}=<a href="../../tt2/@tt_tensor/reshape.html" class="code" title="function [tt2]=reshape(tt1,sz,eps, rl, rr)">reshape</a>(tt{i}.*nrm1,[ncur,r3,rnew]);
0055     tt{i}=permute(tt{i},[1,3,2]);
0056 <span class="keyword">end</span>
0057 tt{1}=tt{1}*<a href="../../tt2/@tt_matrix/conj.html" class="code" title="function [b]=conj(a)">conj</a>(rv');
0058 <span class="comment">%nrmf(1)=norm(tt{1},'fro');</span>
0059 <span class="comment">%nrm_full=sum(log(nrmf(1:d))); nrm1=nrm_full/d; nrm1=exp(nrm1); %This would</span>
0060 <span class="comment">%be the norm of each core</span>
0061 <span class="comment">%Now gradually start compression from the left, using the knowledge</span>
0062 <span class="comment">%of norms</span>
0063 mat=tt{1};
0064 <span class="comment">%return;</span>
0065 mat(abs(mat)&lt;1e-300)=0;
0066 [u0,s0,ru]=svd(mat,0); 
0067 <span class="comment">%If no scaling factors were taken out,</span>
0068 <span class="comment">%then everything would be simple --- nrm=norm(diag(s0)) is the norm,</span>
0069 <span class="comment">%singular values are filtered at absolute accuracy eps*nrm/sqrt(d-1)</span>
0070 <span class="comment">%Here the &quot;True&quot; s0 matrix is up to factor of product of nrm(2:d)</span>
0071 <span class="comment">%so for it we can filter the singular values just at</span>
0072 <span class="comment">%eps*nrmf(1)/sqrt{d-1}</span>
0073 <span class="comment">%nrmf(1)=norm(diag(s0));</span>
0074 <span class="comment">%nrm=norm(diag(s0));</span>
0075 eps1=eps*<a href="../../tt2/@qtt_tucker/norm.html" class="code" title="function [nrm] = norm(tt)">norm</a>(<a href="../../tt2/@qtt_tucker/diag.html" class="code" title="function [qt]=diag(qt)">diag</a>(s0))/sqrt(d-1); <span class="comment">%This is the absolute accuracy to filter with</span>
0076 <span class="comment">%r0=my_chop2(diag(s0),eps1);</span>
0077 r0=numel(find(s0&gt;eps1));
0078 <span class="keyword">if</span> (exists_max_r) r0 = min(r0, max_r); <span class="keyword">end</span>;
0079 <span class="comment">%keyboard;</span>
0080 <span class="comment">%r0=rank(mat,eps1);</span>
0081 u0=u0(:,1:r0);
0082 s0=<a href="../../tt2/@qtt_tucker/diag.html" class="code" title="function [qt]=diag(qt)">diag</a>(s0);
0083 s0=s0(1:r0); <span class="comment">% -eps1*sign(s0);</span>
0084 ru=ru(:,1:r0)*<a href="../../tt2/@qtt_tucker/diag.html" class="code" title="function [qt]=diag(qt)">diag</a>(s0)./nrm1; <span class="comment">%This should be scaled properly</span>
0085 <span class="comment">%ru=ru;</span>
0086 tt{1}=u0.*nrm1; <span class="comment">%Now it is properly scaled</span>
0087 <span class="keyword">for</span> i=2:d-1
0088     <span class="comment">%Convolve tt{i} over the second index</span>
0089 <span class="comment">%     fprintf('norm_tt{%d}=%g, norm_ru = %g\n', i, norm(reshape(tt{i}, size(tt{i},1)*size(tt{i},2), size(tt{i},3)), 'fro'), norm(ru,'fro'));</span>
0090     tt{i}=<a href="ten_conv.html" class="code" title="function [new_core] = ten_conv(core, k, mat)">ten_conv</a>(tt{i},2,<a href="../../tt2/@tt_matrix/conj.html" class="code" title="function [b]=conj(a)">conj</a>(ru));
0091     ncur=<a href="../../tt2/@tt_matrix/size.html" class="code" title="function [sz] = size(tt)">size</a>(tt{i},1);
0092     r2=<a href="../../tt2/@tt_matrix/size.html" class="code" title="function [sz] = size(tt)">size</a>(tt{i},2);
0093     r3=<a href="../../tt2/@tt_matrix/size.html" class="code" title="function [sz] = size(tt)">size</a>(tt{i},3);
0094     <a href="../../tt2/@tt_matrix/core.html" class="code" title="function [tt] = core(tt1,varargin)">core</a>=<a href="../../tt2/@tt_tensor/reshape.html" class="code" title="function [tt2]=reshape(tt1,sz,eps, rl, rr)">reshape</a>(tt{i},[ncur*r2,r3]);
0095     <span class="comment">%r=rank(core,eps1);</span>
0096     <span class="comment">%keyboard;</span>
0097     <a href="../../tt2/@tt_matrix/core.html" class="code" title="function [tt] = core(tt1,varargin)">core</a>(abs(<a href="../../tt2/@tt_matrix/core.html" class="code" title="function [tt] = core(tt1,varargin)">core</a>)&lt;1e-300)=0;
0098     [u0,s0,ru]=svd(<a href="../../tt2/@tt_matrix/core.html" class="code" title="function [tt] = core(tt1,varargin)">core</a>,0);
0099     
0100     nrm=<a href="../../tt2/@qtt_tucker/norm.html" class="code" title="function [nrm] = norm(tt)">norm</a>(<a href="../../tt2/@qtt_tucker/diag.html" class="code" title="function [qt]=diag(qt)">diag</a>(s0));
0101     eps1=eps*nrm/sqrt(d-1); <span class="comment">%Nothing more</span>
0102     <span class="comment">%keyboard;</span>
0103     <span class="comment">%r=my_chop2(diag(s0),eps1);</span>
0104     r=numel(find(s0&gt;eps1));
0105     <span class="keyword">if</span> (exists_max_r) r = min(r, max_r); <span class="keyword">end</span>;
0106     u0=u0(:,1:r);
0107     s0=(s0(1:r,1:r))./nrm1;
0108     ru=ru(:,1:r)*s0;
0109     <a href="../../tt2/@tt_matrix/core.html" class="code" title="function [tt] = core(tt1,varargin)">core</a>=u0.*nrm1;
0110     tt{i}=<a href="../../tt2/@tt_tensor/reshape.html" class="code" title="function [tt2]=reshape(tt1,sz,eps, rl, rr)">reshape</a>(<a href="../../tt2/@tt_matrix/core.html" class="code" title="function [tt] = core(tt1,varargin)">core</a>,[ncur,r2,r]);
0111 <span class="keyword">end</span>
0112 tt{d}=tt{d}*<a href="../../tt2/@tt_matrix/conj.html" class="code" title="function [b]=conj(a)">conj</a>(ru);
0113 <span class="keyword">return</span>
0114 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Wed 08-Feb-2012 18:20:24 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>